import "./App.css";
import { useEffect, useState } from "react";
import { ethers, BrowserProvider, Network } from "ethers";
import { AddressInput } from "./AddressInput";
import { approveSpend, checkBalance } from "./web3";
import { getETHtoUSDCQuote, swapEthUsdc } from "./web3/syncswap";
import { NetworkInfo } from "./types";

let cachedNetworkInfos: NetworkInfo[] | null = null;
let chainId: number | null = null;

const App = () => {
  const [address, setAddress] = useState<string>("");
  const [balance, setBalance] = useState<string>("N/A");
  const [spendAddress, setSpendAddress] = useState<string>("");
  const [spendAmount, setSpendAmount] = useState<string>("");
  const [provider, setProvider] = useState<BrowserProvider | null>(null);
  const [signerAddress, setSignerAddress] = useState<string>("Not Connected");
  const [networkName, setNetworkName] = useState<string>("");
  const [error, setError] = useState<string | null>(null);
  const [showError, setShowError] = useState(false);
  const [ethUsdcQuote, setEthUsdcQuote] = useState<string>("");
  const [quoteAmount, setQuoteAmount] = useState<string>("");
  const [swapIn, setSwapInnAmount] = useState<string>("");
  const [swapOut, setSwapOutAmount] = useState<string>("");
  const [slippageAmount, setSlippageAmount] = useState<string>("");

  useEffect(() => {
    const initializeProvider = async () => {
      if (window.ethereum) {
        const provider = new ethers.BrowserProvider(window.ethereum);
        setProvider(provider);

        const network = await provider.getNetwork();
        loadNetworkInfo(network);

        const accounts = await window.ethereum.request({
          method: "eth_accounts",
        });
        if (accounts.length > 0) {
          setSignerAddress(ethers.getAddress(accounts[0]));
        }

        const handleAccountsChanged = (accounts: string[]) => {
          if (accounts.length === 0) {
            setSignerAddress("Not Connected");
          } else {
            setSignerAddress(ethers.getAddress(accounts[0]));
          }
        };

        window.ethereum.on("accountsChanged", handleAccountsChanged);

        const handleNetworkChanged = async () => {
          await initializeProvider();
        };

        window.ethereum.on("networkChanged", handleNetworkChanged);

        return () => {
          window.ethereum.removeListener(
            "accountsChanged",
            handleAccountsChanged
          );
          window.ethereum.removeListener(
            "networkChanged",
            handleNetworkChanged
          );
        };
      }
    };

    initializeProvider();
  }, []);

  const loadNetworkInfo = async (network: Network) => {
    let networkInfos: NetworkInfo[];

    if (cachedNetworkInfos === null) {
      const response = await fetch("https://chainid.network/chains_mini.json");
      networkInfos = await response.json();
      cachedNetworkInfos = networkInfos;
    } else {
      networkInfos = cachedNetworkInfos;
    }

    // Use the loaded network infos...
    const networkMap = new Map<number, string>(
      networkInfos.map((info) => [info.chainId, info.name])
    );
    const networkName = networkMap.get(Number(network.chainId)) || "Unknown";
    chainId = Number(network.chainId);
    setNetworkName(`${networkName} (${network.chainId})`);
  };

  const displayError = (message: string) => {
    setError(message);
    setShowError(true);
  };

  const clearError = () => {
    setError(null);
    setShowError(false);
  };

  const onConnectWallet = async () => {
    if (!window.ethereum) return;
    await window.ethereum.request({ method: "eth_requestAccounts" });
    const signer = await provider!.getSigner();
    setSignerAddress(await signer.getAddress());
  };

  // Ethereum Mainnet - WETH
  const onCheckBalance = async () => {
    if (chainId !== 1) {
      displayError("Wrong network");
      return;
    }
    setBalance("Checking...");
    if (!provider) {
      displayError("Provider not found");
      return;
    }
    try {
      setBalance(`${await checkBalance(provider, address)} WETH`);
    } catch (err) {
      if (err instanceof Error) {
        setBalance("N/A");
        displayError(err.message);
      }
    }
  };

  const onApproveSpend = async () => {
    if (chainId !== 1) {
      displayError("Wrong network");
      return;
    }
    if (!provider) {
      displayError("Provider not found");
      return;
    }
    try {
      await approveSpend(provider, spendAddress, spendAmount);
    } catch (err) {
      if (err instanceof Error) {
        displayError(err.message);
      }
    }
  };

  // zkSync - SwapSync
  const onGetEthUsdcQuote = async () => {
    if (chainId !== 324) {
      displayError("Wrong network");
      return;
    }
    if (!provider) {
      displayError("Provider not found");
      return;
    }
    setEthUsdcQuote("");
    try {
      const quote = await getETHtoUSDCQuote(
        provider,
        ethers.parseEther(quoteAmount || "1")
      );
      setEthUsdcQuote(`$${Number(quote) / 1e6}`);
    } catch (err) {
      if (err instanceof Error) {
        displayError(err.message);
      }
    }
  };

  const onSwapEthUsdc = async () => {
    if (chainId !== 324) {
      displayError("Wrong network");
      return;
    }
    if (!provider) {
      displayError("Provider not found");
      return;
    }
    if (!slippageAmount.includes("%")) {
      displayError("Slippage must be a percentage");
      return;
    }
    setSwapOutAmount("");
    try {
      const quote = await getETHtoUSDCQuote(
        provider,
        ethers.parseEther(swapIn)
      );
      const slippageFactor = parseFloat(slippageAmount) / 100; // convert percentage to a decimal
      const slippage = BigInt(Math.ceil(Number(quote) * slippageFactor)); // calculate the slippage
      const adjustedQuote = quote - slippage; // subtract the slippage from the quote
      setSwapOutAmount(
        `Swapping ${swapIn} Ether -> $${Number(adjustedQuote) / 1e6}`
      );
      await swapEthUsdc(provider, ethers.parseEther(swapIn), adjustedQuote);
    } catch (err) {
      if (err instanceof Error) {
        displayError(err.message);
      }
    }
  };

  return (
    <div style={{ marginLeft: "10px" }}>
      <h1>Ethers Tests</h1>
      <button onClick={onConnectWallet}>Connect Wallet</button>
      <p>Connected Address: {signerAddress}</p>
      <p>Network: {networkName}</p>
      {error && showError && (
        <div className="modal">
          <div className="modal-content">
            <p style={{ color: "red" }}>{error}</p>
            <button onClick={clearError}>Close</button>
          </div>
        </div>
      )}
      <h2>Ethereum</h2>
      <h3>WETH</h3>
      <div className="my-border">
        <p>
          <b>Check WETH Balance for an address</b> - View Function (Read Only)
        </p>
        <div style={{ display: "flex", alignItems: "flex-start" }}>
          {/* setAddress is not changing anything */}
          <AddressInput
            value={address}
            onChange={setAddress}
            placeholder="Wallet Address"
          />
          <button onClick={onCheckBalance}>Check Balance</button>
          <p style={{ marginLeft: "10px", marginTop: "1px" }}>
            Balance: {balance}
          </p>
        </div>
      </div>
      <div className="my-border">
        <p>
          <b>Approve an address to spend up to X WETH</b> - Write Function
          (State-Changing)
        </p>
        <p style={{ fontSize: 15 }}>
          Opensea Conduit: 0x1E0049783F008A0085193E00003D00cd54003c71
        </p>
        <div style={{ display: "flex", alignItems: "flex-start" }}>
          {/* setSpendAddress is not changing anything */}
          <AddressInput
            value={spendAddress}
            onChange={setSpendAddress}
            placeholder="Operator Address"
          />

          <input
            value={spendAmount}
            onChange={(e) => setSpendAmount(e.target.value)}
            placeholder="Approved Amount"
          />
          <button onClick={onApproveSpend}>Approve</button>
        </div>
      </div>
      <h2>zkSync</h2>
      <h3>SyncSwap</h3>
      <div className="my-border">
        <p>
          <b>Get ETH -&gt; USDC Quote</b> - View Function
        </p>
        <div style={{ display: "flex", alignItems: "flex-start" }}>
          <input
            value={quoteAmount}
            onChange={(e) => setQuoteAmount(e.target.value)}
            placeholder="Ether"
          />
          <button onClick={onGetEthUsdcQuote}>Get Quote</button>
          <p style={{ marginLeft: "10px", marginTop: "1px" }}>
            Quote: {ethUsdcQuote}
          </p>
        </div>
      </div>
      <div className="my-border">
        <p>
          <b>Swap ETH -&gt; USDC</b> - Write Function
        </p>
        <div style={{ display: "flex", alignItems: "flex-start" }}>
          <input
            value={swapIn}
            onChange={(e) => setSwapInnAmount(e.target.value)}
            placeholder="Swap Amount"
          />
          <input
            style={{ width: "70px" }}
            value={slippageAmount}
            onChange={(e) => setSlippageAmount(e.target.value)}
            placeholder="Slippage"
          />
          <button onClick={onSwapEthUsdc}>Swap</button>
          <p style={{ marginLeft: "10px", marginTop: "1px" }}>{swapOut}</p>
        </div>
      </div>
    </div>
  );
};

export default App;
